# 1.Linux文件介绍

`Linux`系统中 "所见皆文件" 

1. `bin`:主要可执行文件
2. `boot` 开机时加载的系统文件
3. `etc` 用户的配置文件和用户信息
4. `home` 存放用户
5. `lib` 库文件
6. `root` 管理员宿主目录(家目录)
7. `usr` 用户安装的第三方库或者文件,用户资源管理文件

# 2.文件操作

## 2.1文件编辑操作

1. `ls -Rl` 递归展示所有文件信息
2. `which` 查看指定命令所在路径
3. `rmdir  文件名`: 删除空目录
4. `cp 文件A 文件B`: 拷贝文件

## 2.2 Linux系统文件类型

* 普通文件:  -

* 目录文件: d

* 字符设备文件:  c

* 块设备文件 :  b

* 软连接 : l

* 管道文件 : p

* 套接字: s

* 未知文件

  Linux中一共有八种文件

## 2.3文件查看操作

1. `cat 文件名`: 查看当前文件的内容
2. `tac 文件名`: 倒着显示文件中的内容(查看日志会使用)
3. `more 文件名`: 可以分屏显示文件(按空格翻页
4. `head 文件名`: 显示默认前10行
5. `tail 文件名`: 显示后10行
6. `tree 文件名`: 按树形显示文件目录

# 3.软链接与硬链接

软链接:   为了保证软连接可以任意搬移,创建时晚上务必使用绝对路径

硬链接:   修改其中一个文件,其硬链接的文件也会发生变化.操作系统给每一个文件赋予唯一的 `inode,` 当有相同的 `inode` 的文件存在时, 彼此同步.删除时,只将硬链接计数减一. 减为0 时, `inode`被释放.

1. `ln -s file file.s` :  软链接相当于`windows`中的快捷方式 (第一个文件使用绝对路径)
2. `ln file file.hard`: 硬链接 相当于指针,同一个地址指向三个文件.但是思想不同,指针对于内存,硬链接对于硬盘,但是硬链接有着相同的`Inode`,即相同的文件编号.



# 4 .查看修改用户和用户组

1. `whoami` : 查看当前用户(`root` 或普通用户)
2. `exit` : 退出`root`用户
3. `chmod  u+x  文件名`: 给文件加一个执行权限.
4. `sudo adduser 新用户名:` 添加用户
5. `sudo chown 新用户名 待修改文件名`:  修改文件所属权限.
6. `sudo addgroup 新用户组:` 添加新用户组



# 5.find命令

1. `find ./ - maxdepth 1 - name '*.jpg'` : 查找一层目录下的所有.jpg文件
2. `find ./ - maxdepth 2 - name '*.jpg':` 查找两层目录下的所有.jpg文件

find命令: 找文件

   * `-type` 按文件类型搜索 `d/p/s/c/b/l/f` : 文件
   * `-name` 按文件名搜索 
     * `find ./ -name "file*.jpg"`
   * -`maxdepth` 指定搜索深度,. 应作为第一个参数出现.
     * `find ./ -maxdepth 1 -name "*.jpg"`

   * `-size` 按文件大小搜索 .单位 : k,M,G

     * `find  /home/itcast -size +20M -size -50M`

     

     -`atime ,mtime , ctime` 天 `amin ,mmin,cmin`分钟

     `-exec`: 将find搜索的结果集执行某一指定命令

     `-ok:` 以交互的方式,将find搜索的结果集执行某一指定命令

     

     

     

# 6.grep命令: 找文件内容

1. grep -r 'copy' ./ -n
2. ps aux | grep 'cupsd' --检索教程结果集.

# 7.压缩文件和下载文件





略



# 8.Vim基本操作

## 8.1 vim基本操作-跳转和删字符

`i` 进入编辑模式，光标前插入字符 

`a` 进入编辑模式，光标后插入字符

`o` 进入编辑模式，光标所在行的下一行插入

`I` 进入编辑模式，光标所在行的行首插入

`A` 进入编辑模式，光标所在行的行末插入字符

`O` 进入编辑模式，光标所在行的上一行插入字符

`s` 删除光标所在字符并进入编辑模式

`S` 删除光标所在行并进入编辑模式

`x` 删除光标所在字符，工作模式不变

`dw` 删除光标所在单词，要求光标在首字母上，如果不在首字母，只会删除当前位置到单词
末，工作模式不变

`D`  删除光标所在位置到行末，工作模式不变

`0`(数字) 光标移到行首，工作模式不变

`$` 光标移到行尾，工作模式不变

`d0` 删除光标所在位置到行首，工作模式不变

`d$` 删除光标所在位置到行末，工作模式不变



命令模式下的光标移动

`h` 左移

`j` 下移

`k` 上移

`l` 右移


命令模式下行跳转

`line-G`  缺点是没有回显

末行模式下行跳转

`:line-回车`

跳转首行

`gg` （命令模式）


跳转末行

`G`  （命令模式）

自动缩进

在这之前要进行vimrc修改，不然自动缩进是8个空格

ubuntu的vimrc位置在`/etc/vim/vimrc`

在文件末尾添加三行：

`set tabstop=4`    //设置制表符宽度为4

`set softtabstop=4`  // 设置软制表符宽度为4

`set shiftwidth=4 `   // 设置缩进空格数为4

`gg=G `（命令模式），无回显




大括号跳转

命令模式下，光标处于左大括号时，使用`%`跳转到对应右大括号，再按`%`跳回去。

其他括号也可以这样





## 8.2 vim基本操作-删除

替换单个字符

`r `命令模式下替换光标选中字符

一段删除，即删除指定区域

光标选中要删除的首字符，按v进入可视模式，再使用hjkl移动到要删除的末尾，按`d`删除

删除整行：

`dd`，删除光标所在行

`n+dd` ，删除从光标开始的n行


## 8.3 vim基本操作-复制粘贴

`yy` 复制光标所在行

`p`  向后粘贴剪切板内容，如果复制整行，这里是粘贴在光标所在位置的下一行

`P`  向前粘贴剪切板内容，如果是整行，这里是粘贴在光标所在位置的上一行


这里提一下，上一节里的dd，不是删除，而是剪切，小时的内容去了剪切板，而不是删掉了
p和P粘贴会出现换行，主要原因是复制整行时，会把行末的换行符也复制下来。


`n-yy ` 复制光标所在位置的n行，包括光标所在行


## 8.4 vim基本操作-查找和替换
查找

`/+findname `  命令模式下查找

按回车键启动查找后，按`n`，会自动找下一个，`N`跳到上一个


查找光标所在单词

光标在目标单词上时，`*`或者`#`查找下一个，这里不要求光标必须在首字母上

替换：末行模式下进行

单行替换  

光标置于待替换行，   :`s` /待替换词/替换词

全文替换
`:%s `/待替换词/替换词           这个默认替换每行的首个，一行有多个目标词时，后面的不会变

`:%s` /待替换词/替换词/g       真正意义上的全局替换

区域替换
`:24,35s` /待替换词/替换词/g     替换24-35行之间的目标词



末行模式下历史命令

`Ctrl-p` 上一条命令

`Ctrl-n` 下一条命令


## 8.5 vim基本操作-其他(分屏)

命令模式下

`u`  撤销操作

`Ctrl-r`  反撤销


分屏，末行模式下

`:sp`   水平分屏

`:vsp ` 竖直分屏

`分屏命令+filename`，分屏并打开这个文件

分屏后屏幕切换，`Ctrl-w-w`

使用`:q`退出光标所在窗口

使用`:qall`退出所有窗口


从vim中跳转`manpage`，命令模式下

将光标放在待查看单词上，按`K`，默认看第一卷
`n+K`，查看第n卷



查看宏定义：命令模式
	光标放在待查看词上，`[+d`即可查看


vim下使用shell命令：末行模式
	`:! + 命令`
操作后，会切换至终端显示结果，出现如下画面，按Enter后回到vim界面




# 9.gcc编译

1. gcc编译可以执行 4 步骤: 预编译, 编译,汇编,链接

   ![image-20220119235432296](C:\Users\Asaki\AppData\Roaming\Typora\typora-user-images\image-20220119235432296.png)



2. `gcc -I./inc hello.c -o hello` 指定头文件的目录,在`/inc`下

3. `gcc -o` 是指定编译后的文件名

4. `gcc  hello.c -o hello2 -g` : 生成调试语句, 可以使用`gdb`调试,然后`gdb hello2`

5. 参数:
      * -I: 指定头文件所在目录文件
      * -c: 只做预处理,编译,汇编.得到二进制文件 ! ! !
      * -g: 编译时添加调试语句. 主要支持 gdb 调试
      * -Wall: 显示所有警告信息.
      * -D: 向程序中"动态" 注册宏定义, #define NAME VALUE
      * -l: 指定动态库库名
      * -L: 指定动态库路径

# 10.动态库与静态库

## 10.1对比

静态库: 对空间要求较低,而时间要求较高的核心程序中(即占用大,耗时少).

动态库: 对时间要求较低,对空间要求较高(即占用小,耗时大)

## 10.2静态库制作及使用

1. 将.c 生成 .o文件    `gcc -c add.c -o add.o`

2. 使用 ar 工具 制作静态库

    `arr rcs lib库名.a  add.o sub.o  div.o`
3. 头文件守卫
    * 源码在前,库在后
    * 例如 : `gcc test.c libmymath.a -o test -Wall (libmymath.a是库,test.c是c文件,test是生成文件)`
    ```
    #ifndef _HEAD_H_
    #define _HEAD_H_
    .....
    #endif
    
## 10.3动态库及使用
1. 将`.c`生成`.o`文件  (生成与位置无关的代码 -fPIC)
    `gcc -c add.c -o add.o -fPIC`
2. 使用`gcc -shared`制作动态库
        `gcc -shared lib库名.so add.o sub.o div.o`
3. 编译可执行程序时,指定所使用的的动态库. -l: 指定库名 -L: 指定库路径.
      `gcc test.c -o a.out -lmymath -L./lib` (注意:-l后面有没有空格都可以,-L后面也没有空格都可)
4. 运行可以执行程序 `./a.out` 出错! ! ! ---ldd a.out --> "not found"
      error while loading shared libraries: libxxx.so: cannot open shared object file: no such file or directory
     原因: 

        * 链接器: 工作于链接阶段  工作需要 -l 和 -L
        * 动态链接器:  工作于程序运行阶段,工作时需要提供动态库所在目录位置.
        * 
                    1)  临时生效: 通过环境变量来改变: `export LD_LIBRARY_PATH=动态库路径`
                        ./a.out 成功 (临时生效,终端重启环境变量失效)

                    2)  永久生效,写入终端配置文件. .bashrc  建议使用绝对路径
                        1) `vi ~/.bashrc
                        2) 写入 export LD_LIBRARY_PATH=动态库路径 保存
                        3) ..bashrc/  source .bshrc /重启终端 --> 让修改后的.bashrc生效
                        4) ./a.out 成功!!!
                      
                    3)  拷贝自定义动态库 到 /lib (标准C库所在目录位置,不太推荐)
                    4)  配置文件法: 
                        1) 修改/etc/ld.so.conf   sudo vi /etc/ld.so.conf  
                        2) 添加你的共享库的绝对路径
                        3) 更新查找共享库的路径使生效 sudo ldconfig -v
                        4) 测试你的程序可否找到共享库 ldd a.out
                        5) ./a.out
                   

5. `ldd a.out` 一个命令可以查看a.out执行时需要加载那些动态库,以及路径

6. 注意: 
   1. 动态库是否加载到内存,取决与程序是否运行
   2. 动态库每次加载的位置不固定
   3. 动,静态库共存时,编译器默认使用动态库
   
   
   
# 11. gdb调试工具 (大前提,程序是你自己写的)
## 11.1基础指令
 * `-g`: 使用改参数编译可执行文件
    `gdb a.out`
 * `list:` `list 1`:列出源码,根据源码指定行号设置断点.
 * `b`:  `b 20` 在20行设置断点
 * `d/delete`: `d 20`在20行取消断点.
 * `run/r`: 运行程序
 * `n/next`: 下一条指令(会越过函数)
 * `s/step`: 下一条指令(会进入函数,但不会进入系统函数)
 * `p/print`: `p i `查看变量的值
 * `continue`: 继续执行断点后续指令,到下一个断点,如果没有直接结束程序
 * `quit`: 退出gdb当前调试
 * `until`: 到指定行接着运行
## 11.2 其他指令
 * `run`: 使用run 查找段错误出现位置.
 * `finish`: 结束当前函数调用,返回到函数调用点(常用于进入无法进入系统函数时,退出当前函数)
 * `set args`: 设置main函数命令行参数
 * `run 字串1 字串2 ...`: 设置main函数命令行参数
 * `info b`: 查看当前断点信息(设置条件断点 b 41 if i = 5)(41行设置断点,如果i =5时,断点才生效)
 * `b 20 if i = 5`: 设置条件断点
 * `ptype j(arr[k]`: 查看变量类型(例如 type = int, type = int *)
 * `bt/backtrace`: 查看函数的调用的栈帧和层级关系,列出当前程序正存活着的栈帧.
 * `frame 0(1)`: 根据编号切换栈帧(因为变量会调用另一个函数,换到另一个函数的栈帧中去看)
 * `display j`: 设置跟踪j参数(可有多个),然后按n/next
 * `undisplay 1`: 取消跟踪1编号的参数 (取消设置跟踪变量,使用跟踪变量的编号)


# 12.Makefile项目管理
    一个规则,两个函数,三个变量
 * 一个规则:
 *  命名: makefile Makefile
  ```
    目标: 依赖条件 
          (一个tab缩进) 命令
          1.目标的时间必须晚于依赖条件的时间,否则,更新目标
          2.依赖条件如果不存在,找寻新的规则去产生依赖.
    ALL: 指定makefile的终极目标(一般makefile的第一行为终极目标,不加all只运行第一行)

  ```
例如
 ```
 ALL:a.out
hello.o:hello.c
        gcc -c hello.c -o hello.o
add.o:add.c
        gcc -c add.c -o add.o
sub.o:sub.c
        gcc -c sub.c -o sub.o
div1.o:div1.c
        gcc -c div1.c -o div1.o

a.out:hello.o add.o sub.o div1.o
        gcc hello.o add.o sub.o div1.o -o a.out
 ```
```
a.out:hello.o add.o sub.o div1.o
        gcc hello.o add.o sub.o div1.o -o a.out

hello.o:hello.c
        gcc -c hello.c -o hello.o
add.o:add.c
        gcc -c add.c -o add.o
sub.o:sub.c
        gcc -c sub.c -o sub.o
div1.o:div1.c
        gcc -c div1.c -o div1.o
```
 * 两个函数: 
    1. src = $(wildcard ./*.c):匹配当前工作目录下的所有.c文件.将文件名组成列表,赋值给变量src
    2. obj = $(patsubst %.c, %.o, &(src)): 将参数3中,包含参数1的部分,替换成参数2.(obj = add.o sub.o div1.o)

















   

   

   

   















