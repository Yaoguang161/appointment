# 1.七层协议模型
* OSI七层模型: 物理层,数据链路层,网络层,传输层,会话层,表示层,应用层.
* TCP/IP四层概念模型: 数据链路层,网络层,传输层,应用层.
* 对应协议:
  * 应用层: `http,ftp,nfs,ssh,telnet...`
  * 传输层: `TCP,UDP`
  * 网络层: `IP,ICMP,IGMP`
  * 链路层: 以太网帧协议,ARP
  

# 2.两个模型
* c/s模型: client-server
* b/s模型: browser-server  


||C/S|B/S|  
|:-:|:-:|:-:|
|优点|缓存大量数据,协议选择灵活,速度快,|安全性,跨平台,开发工作量小
|缺点|安全性,跨平台,开发工作量小|不能缓存大量数据,严格遵守http|


# 3.网络传输流程
* 数据没有封装之前,是不能在网络中传递


# 4.以太网帧协议
ARP协议: 根据IP地址获取mac地址
以太网帧协议: 根据mac地址,完成数据包传输


# 5.IP协议
* 版本: IPv4,IPv6 --4位
* TTL: time to live . 设置数据包在路由节点中的跳转上线.每经过一个路由节点,该值-1,减为0,的路由,有义务将该数据包丢弃.
* 源IP: 32位,  ---4字节
* 目的IP: 32位, ----4字节
  

# 6.UPD协议
* 16位: 源端口号. 2^16 = 65536;
* 16位: 目的端口号


# 7.IP协议
* 16位: 源端口号. 2^16 = 65536
* 16位: 目的端口号
* 32序号
* 32确认序号
* 6个标志位
* 16个窗口大小 2^16 = 65536


# 8.网络套接字 SOCKET
* 一个文件描述符指向一个套接字(该套接字内部是由内核借助两个缓冲区实现)
* 在通信过程中,套接字一定是成对出现
  

# 9.网络字节序
1. 小端法: (pc地址存储) 高位存高地址,低位存低地址
2. 大端法: (网络存储) 高位存低地址, 低位存高地址.

# 10.服务端开发流程
1. 创建`socket`,返回一个文件描述符`lfd---socket()`
   --该文件描述符用于监听客服端连接
2. 将`lfd`和`IP PORT`进行绑定  ---`bind()`
3. 将`lfd`由主动变为被动监听 --`listen()`
4. 接受一个新的连接,得到一个文件描述符`cfd--accept()`
   ---该文件描述符用于和客服端进行通信的
5. 
``` C++
while(1){
  接收数据---read或者recv
  发送数据---write或者send
}
```
6. 关闭文件描述符---`close(lfd) close(cfd)`

# 11.客户端开发流程:
1. 创建socket,返回一个文件描述符cfd---------socket()----该文件描述符是用于和服务端通信
2. 连接服务端---------connect()
3. 
``` C++
while(1){
  //发送数据 ----write或者send
  //接收数据 -----read或者recv
}

```
4. close(cfd)

一些细节:  
1. 调用accept函数不是说新建一个连接,而是从以连接队列中取出一个可用连接



# 12. 粘包的概念
* 粘包: 多次数据发送,首位相连,接收端接收的时候不能正确区分第一次发送多少,第二次发送多少.

* 粘包问题分析和解决??
1. 报头+数据  (最主要的解决方法)
如4位的数据长度+数据 ==========>00101234567890
其中0010表示数据长度,1234567890表示10个字节长度的数据.
另外,发送端和接收端可以协商更为复杂的报文结构,这个报文结构就相当于双方约定的一个协议.
2. 添加结尾标记(不建议用,每个字符都要判断一下)
3. 发送定长数据  
如: 发送20个字节的定长数据.  
  0010xiaozhaobeijing025


# 13.高并发服务器(多进程)
* 思想: 使用多进程:让父进程监听接收新的连接,子进程处理新的连接(接收和发送数据);父进程负责回收子进程.    
* 处理流程:   
  1. 创建socket,得到一个监听的文件描述符lfd =====socket()
  2. 将ldf和ip和端口port进程绑定-----bind()
  3. 设置监听-----listen()
  4. 进入while
``` C++
    while(1){
      //等待有新的客服端连接到来
      cfd =  accept();
      //fork一个子进程,让子进程去处理数据
      pid = fork();
      if(pid < 0){
        exit(-1);
      }else if(pid >  0){
        //关闭通信描述符cfd
        close(cfd);
      }else if(pid ==0){
        //关闭监听文件描述符
        close(lfd);
        //收发数据
        while(1){
          //读数据
          n = read(cfd,buf,sizeof(buf));
          if(n <=0){
            break;
          }
          //发送数据给对方
          write(cfd,buf,n);
        }
        close(cfd);
        //下面的exit()必须有,防止子进程再去创建子进程
        exit();
      }
    }
```

注意点: accept或者read函数是阻塞函数,会被信号打断,此时不应该视为一个错误.errno=EINTR;

父子进程能够共享的:
* 文件描述符(子进程复制父进程的文件描述符)
* mmap共享映射区
  


# 14.多线程服务器开发流程
1. 创建socket,得到一个监听的文件描述符lfd --socket()
2. 将lfd和IP和端口port进行绑定----bind();
3. 设置监听---listen()
4. 
    ```C++
     while(1){
        //接收新的客服端
        cfd = accept();

        //创建一个子线程
        pthread_create(&threadID,NULL,thread_work,&cfd);

        //设置线程为分离属性
        pthread_detach(threadID);
       }

       close(lfd);
    
      子线程执行函数:
        void *thread_work(void *arg){
          //获得参数:通信文件描述符
          int cfd = *(int *) arg;

          while(1){
            //读数据
            n = read(cfd,buf,sizeof(buf));
            if(n <= 0){
              break;
            }
            //发送数据
            write(cfd,buf,n);

          }
          close(cfd);
        } 
    ```
5. 问题:
   1. 子线程能否关闭lfd?    
      子线程不能关闭文件描述符lfd,原因是子线程和主线程共享文件描述符,而不是复制的.
   2. 主线程能否关闭cfd?  
      主线程不能关闭cfd,主线程和子线程还是共享一个cfd,而不是复制的,close之后cfd就会被真正关闭.
   3. 多个子线程共享cfd,会有什么问题发生?  
      
![TCP网络协议](https://github.com/Yaoguang161/image/blob/master/image_1/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)
